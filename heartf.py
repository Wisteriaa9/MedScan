# -*- coding: utf-8 -*-
"""Heartf.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1chnsG9CUIES04et9c0a-UlAgSrheQkmM

HEART DISEASE PREDICTION DATA PREPROCESSING
"""

# Numpy = numerical operations, array manipulation and handling numerical data 
# Pandas = data loading and representation 
# Warnings = issue warnings about issues in code or libraries 
# warnings.filterwarnings('ignore') line of code in Python is used to suppress (ignore) all warning messages


import numpy as np     
import warnings
warnings.filterwarnings('ignore')
import pandas as pd

#loading dataset
heart_ds = pd.read_csv("/content/heart.csv")
heart_ds

#dataset summary
heart_ds.info()

#getting datset statistics  (Describe is a pandas dataFrame && include all categorical and numerical data)
heart_ds.describe(include = "all")

#checking null values (sum and isna= Pandas dataframe )
heart_ds.isna().sum()

#checking duplicate values 
heart_ds.duplicated().sum()

#checking uniques values in each feature
heart_ds.nunique()

#columns returns columns label as pandas index
#select colums of specific datatype = object (categorical values)
cat_col = heart_ds.select_dtypes(include ='object').columns


"""Converting categorical values to numerical values"""

for col in cat_col:
  print(col)
  
  # Prints the unique values of the current categorical column and a list of integers ranging from 0 to the number of unique values minus 1.
  
  print((heart_ds[col].unique()),list(range(heart_ds[col].nunique())))
  heart_ds[col].replace((heart_ds[col].unique()), range(heart_ds[col].nunique()), inplace = True)
  print("*"*90)     # Prints a line of asterisks as a separator
  print()      # Prints an empty line
  
heart_ds
heart_ds['Cholesterol'][heart_ds['Cholesterol']==0]

# inplace=True parameter ensures that the changes are made directly to the original DataFrame.

"""Cholestrol cannot be 0 so replacing it with mean"""

heart_ds['Cholesterol']. replace(0, (heart_ds['Cholesterol'].sum())/918, inplace = True)

heart_ds['Cholesterol'].isna().sum()

"""RestingBP replacing 0 value using KNN"""

heart_ds['RestingBP'][heart_ds['RestingBP']==0]

from sklearn.impute import KNNImputer
# Replace 0 with NaN for KNN imputation
heart_ds['RestingBP'].replace(0, np.nan, inplace=True)

# Instantiate KNNImputer with 3 neighbors
imputer = KNNImputer(n_neighbors=3)

# Fit and transform the DataFrame using KNN imputer
after_impute = imputer.fit_transform(heart_ds)

# Convert the result back to a DataFrame
heart_ds = pd.DataFrame(after_impute, columns=heart_ds.columns)

heart_ds['RestingBP'].isnull().sum()

withoutOldPeak = heart_ds.columns

# This line removes the column named 'Oldpeak' from the withoutOldPeak variable.
withoutOldPeak = withoutOldPeak.drop('Oldpeak')

# converts the data type of those columns to 'int32'.
heart_ds[withoutOldPeak] = heart_ds[withoutOldPeak].astype('int32')

heart_ds.info()

heart_ds

"""after preprocessing"""

#This line creates a DataFrame X by dropping the column labeled 'HeartDisease' from the original DataFrame heart_ds.
X = heart_ds.drop(columns='HeartDisease', axis=1)

# Y containing the values of the 'HeartDisease' column from the original DataFrame heart_ds
Y = heart_ds['HeartDisease']

print(X)
print(Y)


"""splitting data into training and test data"""

from sklearn.model_selection import train_test_split

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, stratify=Y, random_state=2)
# x = independent variable used to make predictions
# y = dependent variable you are trying to predict
# 0.2, meaning 20% data = testing, 80% = training.

print(X.shape, X_train.shape, X_test.shape)



"""Model Training"""

from sklearn.linear_model import LogisticRegression
model = LogisticRegression()
model.fit(X_train, Y_train)   # trains the model using training data 



"""Model Evaluation

# Accuracy score
"""

# accuracy on training data
from sklearn.metrics import accuracy_score
X_train_prediction = model.predict(X_train)
training_data_accuracy = accuracy_score(X_train_prediction, Y_train)

print('Accuracy on Training data : ', training_data_accuracy)

from sklearn.metrics import accuracy_score
X_test_prediction = model.predict(X_test)
test_data_accuracy = accuracy_score(X_test_prediction, Y_test)

print('Accuracy on Test data : ', test_data_accuracy)




"""building a predictive system"""

# Input data for prediction
input_data = (38,0,1,138,175,0 ,0,173, 0 ,0.0,0)
# Convert input data to a NumPy array
input_data_as_numpy_array= np.asarray(input_data)
# Reshape the array to match the expected input shape for prediction (1 sample, -1 features)
input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)
# Use the trained model to make predictions
prediction = model.predict(input_data_reshaped)

print(prediction)

if (prediction[0]== 0):
  print('The Person does not have a Heart Disease')
else:
  print('The Person has Heart Disease')




"""Saving trained model"""

# .sav = reuasability , deployment, cnsistency, sharing with others

#pickle = saving and loading models
import pickle

filename = 'heart_disease_model.sav'
pickle.dump(model, open(filename, 'wb'))   #serialize data , binary write mode 

# loading the saved model
#binary read mode ('rb') , deserialize data 
loaded_model = pickle.load(open('heart_disease_model.sav', 'rb'))

for column in X.columns:
  print(column)